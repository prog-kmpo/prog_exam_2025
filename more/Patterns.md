# Паттерны проектирования GoF: подробное описание

Паттерны проектирования (Design Patterns) — это обобщённый опыт проектирования программных систем, оформленный в виде типовых решений часто возникающих проблем. Они не являются готовыми алгоритмами или библиотеками, а представляют собой архитектурные приёмы, помогающие писать более гибкий, понятный и поддерживаемый код.

Классические паттерны были описаны группой авторов, известных как **Gang of Four (GoF)**. Всего выделяют **22 паттерна**, которые делятся на три большие группы: **порождающие**, **структурные** и **поведенческие**.

---

## 1. Singleton (Синглтон)

Назначение паттерна **Singleton** заключается в том, чтобы гарантировать существование только одного экземпляра определённого класса в программе. Это необходимо в тех случаях, когда несколько экземпляров объекта могут привести к ошибкам или избыточному потреблению ресурсов.

Singleton часто используется для логгеров, конфигурационных файлов, менеджеров подключений к базе данных. Основная идея — скрыть конструктор класса и предоставить специальный метод доступа к единственному объекту.

---

## 2. Factory Method (Фабричный метод)

Фабричный метод решает проблему жёсткой привязки к конкретным классам при создании объектов. Он выносит логику создания объекта в отдельный метод, который может быть переопределён в подклассах.

Это позволяет расширять систему новыми типами объектов, не изменяя уже существующий код, что соответствует принципу открытости/закрытости.

---

## 3. Abstract Factory (Абстрактная фабрика)

Абстрактная фабрика предназначена для создания целых семейств взаимосвязанных объектов. Клиентский код работает с абстракциями и не знает, какие конкретные классы используются.

Данный паттерн особенно полезен, когда система должна поддерживать несколько платформ или конфигураций, например, разные стили интерфейса для различных операционных систем.

---

## 4. Builder (Строитель)

Паттерн **Builder** применяется для создания сложных объектов, которые состоят из множества частей или имеют большое количество параметров. Процесс создания разбивается на этапы.

Это позволяет получать разные представления одного и того же объекта, не изменяя код его создания.

---

## 5. Prototype (Прототип)

Prototype используется в ситуациях, когда создание нового объекта слишком ресурсоёмко. Вместо этого создаётся копия уже существующего объекта.

Паттерн позволяет ускорить работу программы и упростить процесс создания объектов со сложной внутренней структурой.

---

## 6. Adapter (Адаптер)

Адаптер применяется для согласования несовместимых интерфейсов. Он оборачивает один объект, преобразуя его интерфейс в форму, понятную клиенту.

Часто используется при подключении сторонних библиотек или устаревшего кода.

---

## 7. Bridge (Мост)

Bridge разделяет абстракцию и реализацию, позволяя изменять их независимо друг от друга. Это снижает количество классов и упрощает расширение системы.

Паттерн полезен, когда существует несколько измерений изменений.

---

## 8. Composite (Компоновщик)

Компоновщик позволяет объединять объекты в древовидные структуры и работать с ними единообразно. Клиент может обращаться как к отдельному объекту, так и к группе объектов одинаковым способом.

Используется в файловых системах и графических интерфейсах.

---

## 9. Decorator (Декоратор)

Декоратор позволяет динамически добавлять объекту новое поведение, не изменяя его класс. Объект оборачивается в другой объект-декоратор.

Это более гибкая альтернатива наследованию.

---

## 10. Facade (Фасад)

Фасад предоставляет простой интерфейс к сложной системе классов. Он скрывает внутреннюю реализацию и упрощает использование подсистемы.

Повышает читаемость и снижает связанность кода.

---

## 11. Flyweight (Приспособленец)

Flyweight используется для оптимизации памяти при работе с большим количеством однотипных объектов. Общее состояние выносится и разделяется между объектами.

Актуален для графики, текстовых редакторов и игр.

---

## 12. Proxy (Заместитель)

Proxy представляет собой объект-заместитель, который контролирует доступ к реальному объекту. Он может выполнять дополнительные действия до или после обращения.

Применяется для ленивой загрузки и защиты ресурсов.

---

## 13. Chain of Responsibility (Цепочка ответственности)

Запрос передаётся по цепочке обработчиков до тех пор, пока один из них не обработает его. Отправитель запроса не знает, кто именно его обработает.

Паттерн снижает связанность между объектами.

---

## 14. Command (Команда)

Command инкапсулирует запрос в виде объекта. Это позволяет параметризовать клиентов различными запросами и реализовывать отмену операций.

Часто используется в интерфейсах пользователя.

---

## 15. Interpreter (Интерпретатор)

Интерпретатор описывает грамматику простого языка и механизм интерпретации выражений. Каждое правило языка представлено отдельным классом.

Применяется для DSL и правил.

---

## 16. Iterator (Итератор)

Iterator предоставляет стандартный способ последовательного обхода элементов коллекции без раскрытия её внутренней структуры.

Упрощает работу с различными типами коллекций.

---

## 17. Mediator (Посредник)

Mediator централизует взаимодействие между объектами, уменьшая количество прямых связей. Объекты общаются не напрямую, а через посредника.

Часто используется в GUI.

---

## 18. Memento (Хранитель)

Memento позволяет сохранять и восстанавливать состояние объекта без нарушения инкапсуляции. Состояние хранится во внешнем объекте.

Используется для Undo / Redo.

---

## 19. Observer (Наблюдатель)

Observer реализует зависимость «один ко многим». Изменение состояния одного объекта автоматически уведомляет всех подписчиков.

Широко используется в событийных системах.

---

## 20. State (Состояние)

State позволяет объекту изменять своё поведение в зависимости от внутреннего состояния. Каждое состояние оформляется отдельным классом.

Упрощает реализацию сложной логики.

---

## 21. Strategy (Стратегия)

Strategy определяет набор алгоритмов и инкапсулирует каждый из них. Алгоритмы можно менять во время выполнения программы.

Повышает гибкость и расширяемость.

---

## 22. Template Method (Шаблонный метод)

Template Method задаёт общий алгоритм, оставляя подклассам возможность реализовывать отдельные шаги.

Позволяет повторно использовать общий код.

